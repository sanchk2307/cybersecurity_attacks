{
  "permissions": {
    "allow": [
      "Bash(tail:*)",
      "Bash(cd:*)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python script.py 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi install 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && rm -f data/df.csv && time pixi run python script.py --no-figures 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run run-pipeline 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python -c \"\nfrom src.config import load_data\nfrom src.eda_pipeline import run_eda\nimport pandas as pd\n\ndf_original, df = load_data\\(\\)\n\n# Run up to just before the crosstab call to check for duplicate columns\n# Check what columns exist\ndupes = df.columns[df.columns.duplicated\\(\\)].tolist\\(\\)\nprint\\('Duplicate columns after load_data:', dupes\\)\n\" 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python -c \"\nimport pandas as pd\nprint\\('pandas version:', pd.__version__\\)\n\" 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python -c \"\nfrom src.config import load_data\nimport pandas as pd\nimport numpy as np\n\ndf_original, df = load_data\\(\\)\n\n# Simulate what run_eda does up to the crosstab call\n# First parse the date\ndf['date'] = pd.to_datetime\\(df['Timestamp']\\)\ncol_name = 'Timestamp'\ncol_pos = df.columns.get_loc\\(col_name\\)\ncol_insert = [\n    'date dd', 'date MW', 'date MW1', 'date MW2', 'date MW3',\n    'date WD', 'date WD1', 'date WD2', 'date WD3', 'date WD4',\n    'date WD5', 'date WD6', 'date H', 'date H1', 'date H2',\n    'date H3', 'date M', 'date M1', 'date M2', 'date M3',\n    'date M4', 'date M5', 'date M6', 'date M7', 'date M8',\n    'date M9', 'date M10', 'date M11',\n]\nna_cols = {'date dd', 'date MW', 'date WD', 'date H', 'date M'}\nnew_cols = pd.DataFrame\\(\n    {c: pd.NA if c in na_cols else 0 for c in col_insert},\n    index=df.index,\n\\)\ndf = pd.concat\\(\n    [df.iloc[:, :col_pos + 1], new_cols, df.iloc[:, col_pos + 1:]],\n    axis=1,\n\\)\ndf['date dd'] = df['date'].dt.floor\\('D'\\)\ndf.loc[df['date'].dt.day <= 7, 'date MW'] = 'MW1'\ndf['date MW'] = df['date MW'].fillna\\('MW4'\\)\n\n# Now check the column\nprint\\('date MW shape:', df['date MW'].shape\\)\nprint\\('date MW type:', type\\(df['date MW']\\)\\)\nprint\\('date MW ndim:', df['date MW'].ndim\\)\n\n# Check for dupes\ndupes = df.columns[df.columns.duplicated\\(\\)].tolist\\(\\)\nprint\\('Duplicate columns:', dupes\\)\n\n# Try the crosstab\ntry:\n    ct = pd.crosstab\\(\n        index=[df['date MW']],\n        columns=df['Attack Type'],\n        margins=True,\n        margins_name='n obs',\n        normalize=False,\n    \\)\n    print\\('Crosstab succeeded'\\)\n    print\\(ct\\)\nexcept Exception as e:\n    print\\(f'Crosstab failed: {e}'\\)\n\" 2>&1)",
      "Bash(head:*)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python -c \"\nfrom src.config import load_data\nimport pandas as pd\nimport src.eda_pipeline as ep\nimport src.feature_engineering as fe\n\ndf_original, df = load_data\\(\\)\n\n# Replicate run_eda steps up to the failing crosstab\nimport warnings\nwarnings.filterwarnings\\('ignore'\\)\n\ndf = df.rename\\(columns={'Timestamp': 'date', 'Alerts/Warnings': 'Alert Trigger'}\\)\ndf = df.drop\\(['User Information', 'Payload Data'], axis=1, errors='ignore'\\)\n\ncol_name = 'date'\ndf[col_name] = pd.to_datetime\\(df[col_name]\\)\n\ncol_pos = df.columns.get_loc\\(col_name\\)\ncol_insert = [\n    'date dd', 'date MW', 'date MW1', 'date MW2', 'date MW3',\n    'date WD', 'date WD1', 'date WD2', 'date WD3', 'date WD4',\n    'date WD5', 'date WD6', 'date H', 'date H1', 'date H2',\n    'date H3', 'date M', 'date M1', 'date M2', 'date M3',\n    'date M4', 'date M5', 'date M6', 'date M7', 'date M8',\n    'date M9', 'date M10', 'date M11',\n]\nna_cols = {'date dd', 'date MW', 'date WD', 'date H', 'date M'}\nnew_cols = pd.DataFrame\\(\n    {c: pd.NA if c in na_cols else 0 for c in col_insert},\n    index=df.index,\n\\)\ndf = pd.concat\\(\n    [df.iloc[:, :col_pos + 1], new_cols, df.iloc[:, col_pos + 1:]],\n    axis=1,\n\\)\n\ndf['date dd'] = df['date'].dt.floor\\('D'\\)\nsched = [0, 7, 14, 22]\nfor day_filter in range\\(0, len\\(sched\\) - 1\\):\n    day_bully = \\(df['date'].dt.day > sched[day_filter]\\) & \\(df['date'].dt.day <= sched[day_filter + 1]\\)\n    df.loc[day_bully, f'date MW{day_filter + 1}'] = 1\n    df.loc[day_bully, 'date MW'] = f'MW{day_filter + 1}'\ndf['date MW'] = df['date MW'].fillna\\('MW4'\\)\n\n# Check for duplicate columns\ndupes = df.columns[df.columns.duplicated\\(\\)].tolist\\(\\)\nprint\\('Duplicate columns:', dupes\\)\nprint\\('date MW occurrences:', list\\(df.columns\\).count\\('date MW'\\)\\)\nsel = df['date MW']\nprint\\('date MW type:', type\\(sel\\).__name__, 'ndim:', sel.ndim\\)\nif sel.ndim > 1:\n    print\\('date MW shape:', sel.shape\\)\n\n# Try crosstab\ntry:\n    ct = pd.crosstab\\(index=df['date MW'], columns=df['Attack Type'], margins=True, margins_name='n obs', normalize=False\\)\n    print\\('Crosstab OK'\\)\nexcept Exception as e:\n    print\\(f'Crosstab FAILED: {e}'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python script.py --no-figures 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python script.py --model-only 2>&1)",
      "Bash(grep:*)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python -u script.py --model-only 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && time pixi run python -u script.py --model-only 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python -c \"\nimport src.data_preparation as dp\nimport src.utils as ut\nimport src.feature_engineering as fe\nprint\\('All modules import OK'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python pipeline.py --no-figures 2>&1)",
      "Bash(cd /c/Users/eugen/cybersecurity_attacks && pixi run python -c \"\nimport pandas as pd\ndf = pd.read_parquet\\('data/pre_model_df.parquet'\\)\nprint\\('Shape:', df.shape\\)\nprint\\('Dtypes:'\\)\nprint\\(df.dtypes\\)\nprint\\(\\)\nprint\\('Memory \\(MB\\):', df.memory_usage\\(deep=True\\).sum\\(\\) / 1e6\\)\n\" 2>&1)"
    ]
  }
}
